前置过滤（Pre-Check）
规则： 在开始深度分析前，必须先判断本次 diff 是否属于 “琐事（Trivial Changes）”。
判定标准（满足任一即可）：
1. 纯文档/注释：仅修改了 README, .md 文件，或代码中的注释（//, /** */）。
2. 代码格式化：仅涉及空格、缩进、换行、分号等风格调整（Prettier/ESLint 自动修复）。
3. 纯文案修改：仅修改了 UI 显示的静态文本、错误提示语，不涉及逻辑分支。
4. 构建/配置微调：仅修改了 .gitignore, package.json (版本号/依赖), tsconfig.json, .env.example 等配置文件。
5. CI/CD 脚本：仅修改了 GitHub Actions, Dockerfile 等部署脚本。
6. 很小的参数改动
执行动作：
- 如果命中上述标准：
  - 立即停止所有后续的“深度分析”、“风险评估”、“验证方案”。
  - 仅输出两行内容：
    1. 符合 Conventional Commits 的标题（如 docs: update README, chore: bump version）。
    2. 一行简短的改动说明。
- 如果未命中（涉及逻辑修改）：
  - 继续执行后续的完整分析流程。

请基于以下 Git diff 生成提交信息，确保每个部分的内容都涵盖以下几个维度：
1. diff内容概述：

- 标题（必填，第一行）：
使用 type(scope): summary 的格式，简洁描述本次改动的核心内容，保证在 commit 历史中一眼能看出重点。
  
  - type：改动类型（如 feat, fix, refactor, docs, test, chore 等）。
  - scope：改动范围（如 auth, api, ui, db 等）。
  - summary：一句话描述改动的主要目标或结果。
    
    
- （简述 diff 改动）：
  用 1–3 句话简要说明这次提交的主要改动内容，覆盖关键点但不展开细节，这里的内容要方便一眼看明白，理解改动内容（专业部分和细节会在后续部分说明）。
  
2. 代码改动的动机与目标

- 为什么进行这些改动？
  
  - 解释本次提交背后的目标和动机，例如：是否为了满足用户需求，解决某个痛点，或者是提升现有功能的性能？
  - 如果是响应用户反馈或业务需求，简要说明需求背景及其重要性。
  - 如果是为了技术债务清理、系统重构或模块优化，请明确说明。
    
3. 改动的影响

- 请评估本次提交对系统或项目的影响。
  
  - 这次变更是否影响了系统的其他模块？例如，是否涉及到跨模块的改动，影响了核心业务逻辑或数据库结构？
  - 是否新增了外部依赖（如库、服务等）或者改变了现有依赖？
  - 这次改动是否对系统的可扩展性、可维护性或性能产生了显著影响？请简述这些影响。

4. 技术细节与实现方式

- 本次提交采用了哪些技术方案或实现方法？
  - 详细描述本次改动涉及的核心实现，
  
5. 关键风险与技术债评估（Critical Risks & Tech Debt）

*   过滤原则（重要）：
    *   当前处于 PMF 前敏捷开发阶段（小团队），我们容忍非致命的技术债务、边缘情况的竞态条件、以及非核心路径的代码冗余。
    *   严禁提出“代码风格优化”、“过度设计”、“理论上可能发生但概率极低”的改进建议。
    *   严禁为了追求完美架构而建议重构。

*   仅在检测到以下“显性阻碍”时输出此部分（否则直接留空或跳过）：
    1.  数据丢失/破坏风险：是否存在导致用户数据不可逆丢失、覆盖或污染的逻辑？
    2.  服务崩溃风险：是否存在未捕获的异常可能导致进程 Crash 或服务完全不可用？
    3.  核心业务阻断：改动是否可能导致主流程（Happy Path）完全走不通？
    4.  安全漏洞：是否存在明显的 SQL 注入、密钥泄露或越权访问风险？
    5.  回滚困难：如果涉及数据库 Schema 变更，是否缺失了向下兼容性？

*   输出格式（若有风险）：
     *   评估结论：[阻断 / MUST FIX] 或 [风险接受 / TECH DEBT] （必填，必须写在第一行）
    *   风险类型：[数据安全 / 服务稳定性 / 业务阻断]
    *   场景描述：简述在什么操作下会触发该问题。
应对建议：
- 如果是 [阻断] -> 必须给出具体的快速修复方案。
- 如果是 [风险接受] -> 必须说明“为什么当前阶段可以容忍该风险”（例如：发生概率极低、有日志监控兜底等）。

回滚注意事项：仅在涉及数据库结构变更或破坏性 API 变更时填写，否则写“无”。

6. 验证方案（Verification Plan）
- 目标：告诉 Reviewer 如何在不看代码的情况下，确认改动已生效且无副作用。
- 输出原则：
  - 优先描述“可观测的行为变化”（日志、DB数据、UI表现），而非猜测具体的性能数值。
  - 仅在专门进行性能优化（如重构算法、加索引）时，才输出预期的性能指标变化。
- 内容涵盖（选填最相关的一项即可）：
  1. 自动化测试：新增了哪个测试用例？（如 npm test -- -t 'should regenerate'）
  2. 日志观测：上线后应搜索什么关键字？（如 grep "Regenerate triggered" app.log）
  3. 数据状态：数据库中会多出什么记录？（如 Redis list length should increase by 1）
- 格式示例：
  - 验证方式：[日志 / 数据库 / UI / 测试]
  - 预期结果：用户点击按钮后，日志输出 [INFO] Regenerate started，且 Redis 中 history 列表长度不变（因回滚机制）。
---

### **输入分层：**

#### **外圈（Context - 上下文与背景）：**
这里混合了静态信息（架构、原则）和动态信息（当前正在做的任务）。

* **项目目标与背景**：该层次为整体项目提供宏观视角，帮助理解项目的背景、原则、战略目标、技术架构等，不涉及具体代码。它为理解每个提交的上下文提供指导，使提交与整体目标保持一致。

```
===================
【项目背景与当前任务】
{project_arch}          # 架构
{project_principle}     # 原则
{current_mission}       # 任务
===================
```


#### **内圈（具体代码 diff）：**

* **代码层面的变更**：此部分是最具体的，聚焦在代码的修改、修复、优化等技术实现方面。

```
===================
{git_push_commit_logs}
===================
```


直接按照上面的要求输出内容，详细的描述




